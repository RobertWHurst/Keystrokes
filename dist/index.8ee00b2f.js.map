{"mappings":"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","sources":["node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/src/_define_property.mjs","node_modules/.pnpm/@rwh+keystrokes@1.0.0-beta.4/node_modules/@rwh/keystrokes/dist/src/handler-state.ts","node_modules/.pnpm/@rwh+keystrokes@1.0.0-beta.4/node_modules/@rwh/keystrokes/dist/src/key-combo-state.ts","node_modules/.pnpm/@rwh+keystrokes@1.0.0-beta.4/node_modules/@rwh/keystrokes/dist/src/keystrokes.ts","node_modules/.pnpm/@rwh+keystrokes@1.0.0-beta.4/node_modules/@rwh/keystrokes/dist/src/index.ts","src/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","export type KeyEvent<E> = {\n  key: string\n  originalEvent?: E\n}\n\nexport type HandlerFn<E> = (event: E) => void\n\nexport type HandlerObj<E> = {\n  onPressed?: HandlerFn<E>\n  onPressedWithRepeat?: HandlerFn<E>\n  onReleased?: HandlerFn<E>\n}\n\nexport type Handler<E> = HandlerFn<E> | HandlerObj<E>\n\nexport class HandlerState<E> {\n  _onPressed?: HandlerFn<E>\n  _onPressedWithRepeat?: HandlerFn<E>\n  _onReleased?: HandlerFn<E>\n  _isPressed: boolean\n  _identity: Handler<E>\n\n  constructor(handler: Handler<E>) {\n    this._isPressed = false\n    this._identity = handler\n\n    if (typeof handler === 'function') {\n      this._onPressedWithRepeat = handler\n    } else {\n      this._onPressed = handler.onPressed\n      this._onPressedWithRepeat = handler.onPressedWithRepeat\n      this._onReleased = handler.onReleased\n    }\n  }\n\n  get isEmpty() {\n    return !this._onPressed && !this._onPressedWithRepeat && !this._onReleased\n  }\n\n  isOwnHandler(handler: Handler<E>) {\n    return this._identity === handler\n  }\n\n  executePressed(event: E) {\n    if (!this._isPressed) {\n      this._onPressed?.(event)\n    }\n\n    this._isPressed = true\n    this._onPressedWithRepeat?.(event)\n  }\n\n  executeReleased(event: E) {\n    if (this._isPressed) {\n      this._onReleased?.(event)\n    }\n\n    this._isPressed = false\n  }\n}\n","import type { KeyEvent, Handler } from './handler-state'\nimport { HandlerState } from './handler-state'\n\nexport type KeyComboEvent<E> = {\n  keyCombo: string\n  originalEvent?: E\n}\n\nexport class KeyComboState<E> {\n  private static _parseCache: Record<string, string[][][]> = {}\n  private static _normalizationCache: Record<string, string> = {}\n\n  static parseKeyCombo(keyComboStr: string) {\n    if (KeyComboState._parseCache[keyComboStr]) {\n      return KeyComboState._parseCache[keyComboStr]\n    }\n\n    const s = keyComboStr.toLowerCase()\n\n    let o = ''\n    let k: string[] = []\n    let x: string[][] = [k]\n    let y: string[][][] = [x]\n    const z: string[][][][] = [y]\n    let isEscaped = false\n\n    for (let i = 0; i < keyComboStr.length; i += 1) {\n      if (s[i] === '\\\\') {\n        isEscaped = true\n      } else if ((s[i] === '+' || s[i] === '>' || s[i] === ',') && !isEscaped) {\n        if (o) {\n          // TODO: Nice error message\n        }\n        o = s[i]\n      } else if (s[i].match(/[^\\s]/)) {\n        if (o) {\n          if (o === ',') {\n            k = []\n            x = [k]\n            y = [x]\n            z.push(y)\n          } else if (o === '>') {\n            k = []\n            x = [k]\n            y.push(x)\n          } else if (o === '+') {\n            k = []\n            x.push(k)\n          }\n          o = ''\n        }\n        isEscaped = false\n        k.push(s[i])\n      }\n    }\n\n    const sequences = z.map(y => y.map(x => x.map(k => k.join(''))))\n    KeyComboState._parseCache[keyComboStr] = sequences\n    return sequences\n  }\n\n  static stringifyKeyCombo(keyCombo: string[][][]) {\n    return keyCombo\n      .map(s =>\n        s\n          .map(u =>\n            u\n              .map(k => {\n                if (k === '+') {\n                  return '\\\\+'\n                }\n                if (k === '>') {\n                  return '\\\\>'\n                }\n                if (k === ',') {\n                  return '\\\\,'\n                }\n                return k\n              })\n              .join('+'),\n          )\n          .join('>'),\n      )\n      .join(',')\n  }\n\n  static normalizeKeyCombo(keyComboStr: string) {\n    if (KeyComboState._normalizationCache[keyComboStr]) {\n      return KeyComboState._normalizationCache[keyComboStr]\n    }\n    const normalized = this.stringifyKeyCombo(this.parseKeyCombo(keyComboStr))\n    KeyComboState._normalizationCache[keyComboStr] = normalized\n    return normalized\n  }\n\n  get isPressed() {\n    return !!this._isPressedWithFinalKey\n  }\n\n  private _normalizedKeyCombo: string\n  private _parsedKeyCombo: string[][][]\n  private _handlerState: HandlerState<KeyComboEvent<E>>\n  private _isPressedWithFinalKey: string\n  private _sequenceIndex: number\n\n  constructor(keyCombo: string, handler: Handler<KeyComboEvent<E>> = {}) {\n    this._normalizedKeyCombo = KeyComboState.normalizeKeyCombo(keyCombo)\n    this._parsedKeyCombo = KeyComboState.parseKeyCombo(keyCombo)\n    this._handlerState = new HandlerState(handler)\n    this._isPressedWithFinalKey = ''\n    this._sequenceIndex = 0\n  }\n\n  isOwnHandler(handler: Handler<KeyComboEvent<E>>) {\n    return this._handlerState.isOwnHandler(handler)\n  }\n\n  executePressed(event: KeyEvent<E>) {\n    if (this._isPressedWithFinalKey !== event.key) {\n      return\n    }\n    this._handlerState.executePressed(this._wrapEvent(event))\n  }\n\n  executeReleased(event: KeyEvent<E>) {\n    if (this._isPressedWithFinalKey !== event.key) {\n      return\n    }\n    this._isPressedWithFinalKey = ''\n    this._handlerState.executeReleased(this._wrapEvent(event))\n  }\n\n  updateState(activeKeys: string[]) {\n    const sequence = this._parsedKeyCombo[this._sequenceIndex]\n\n    // Do nothing if no keys are pressed\n    if (activeKeys.length === 0) {\n      return\n    }\n\n    // ensure all sequence keys are pressed\n    let activeKeyIndex = 0\n    for (const unit of sequence) {\n      let unitEndIndex = activeKeyIndex\n      for (const key of unit) {\n        let foundKey = false\n        for (let i = activeKeyIndex; i < activeKeys.length; i += 1) {\n          const activeKey = activeKeys[i]\n          if (key === activeKey) {\n            if (i > unitEndIndex) {\n              unitEndIndex = i\n            }\n            foundKey = true\n            break\n          }\n        }\n        if (!foundKey) {\n          if (this._handlerState.isEmpty) {\n            this._isPressedWithFinalKey = ''\n          }\n          return\n        }\n      }\n      activeKeyIndex = unitEndIndex\n    }\n\n    // ensure all active keys are part of sequence\n    for (const activeKey of activeKeys) {\n      let foundActiveKey = false\n      for (const unit of sequence) {\n        for (const key of unit) {\n          if (activeKey === key) {\n            foundActiveKey = true\n            break\n          }\n        }\n      }\n      if (!foundActiveKey) {\n        this._sequenceIndex = 0\n        return\n      }\n    }\n\n    if (this._sequenceIndex < this._parsedKeyCombo.length - 1) {\n      this._sequenceIndex += 1\n      return\n    }\n\n    this._sequenceIndex = 0\n    this._isPressedWithFinalKey = activeKeys[activeKeys.length - 1]\n  }\n\n  _wrapEvent(keyEvent: KeyEvent<E>): KeyComboEvent<E> {\n    return {\n      keyCombo: this._normalizedKeyCombo,\n      originalEvent: keyEvent.originalEvent,\n    }\n  }\n}\n","import { Handler, HandlerState, KeyEvent } from './handler-state'\nimport { KeyComboEvent, KeyComboState } from './key-combo-state'\n\nexport type OnActiveEventBinder = (handler: () => void) => (() => void) | void\nexport type OnKeyEventBinder<E> = (handler: (event: KeyEvent<E>) => void) => (() => void) | void\n\nexport type KeystrokesOptions<E = KeyboardEvent> = {\n  onActive?: OnActiveEventBinder\n  onInactive?: OnActiveEventBinder\n  onKeyPressed?: OnKeyEventBinder<E>\n  onKeyReleased?: OnKeyEventBinder<E>\n  selfReleasingKeys?: string[]\n  keyRemap?: Record<string, string>\n}\n\nconst nextTickBinder =\n  typeof requestAnimationFrame === 'function'\n    ? (r: () => void) => requestAnimationFrame(r)\n    : (f: () => void) => setTimeout(f, 0)\n\nexport const nextTick = () => new Promise<void>(r => nextTickBinder(r))\n\nconst defaultOnActiveBinder: OnActiveEventBinder = handler => {\n  try {\n    const handlerWrapper = () => handler()\n    addEventListener('focus', handlerWrapper)\n    return () => {\n      removeEventListener('focus', handlerWrapper)\n    }\n  } catch {}\n}\n\nconst defaultOnInactiveBinder: OnActiveEventBinder = handler => {\n  try {\n    const handlerWrapper = () => handler()\n    addEventListener('blur', handlerWrapper)\n    return () => {\n      removeEventListener('blur', handlerWrapper)\n    }\n  } catch {}\n}\n\nconst defaultOnKeyPressedBinder: OnKeyEventBinder<KeyboardEvent> = handler => {\n  try {\n    const handlerWrapper = (e: KeyboardEvent) => handler({ key: e.key, originalEvent: e })\n    document.addEventListener('keydown', handlerWrapper)\n    return () => {\n      document.removeEventListener('keydown', handlerWrapper)\n    }\n  } catch {}\n}\n\nconst defaultOnKeyReleasedBinder: OnKeyEventBinder<KeyboardEvent> = handler => {\n  try {\n    const handlerWrapper = (e: KeyboardEvent) => handler({ key: e.key, originalEvent: e })\n    document.addEventListener('keyup', handlerWrapper)\n    return () => {\n      document.removeEventListener('keyup', handlerWrapper)\n    }\n  } catch {}\n}\n\nexport class Keystrokes<E = KeyboardEvent> {\n  private _isActive: boolean\n  private _isUpdatingKeyComboState: boolean\n\n  private _unbinder: (() => void) | undefined\n\n  private _onActiveBinder: OnActiveEventBinder\n  private _onInactiveBinder: OnActiveEventBinder\n  private _onKeyPressedBinder: OnKeyEventBinder<E>\n  private _onKeyReleasedBinder: OnKeyEventBinder<E>\n  private _selfReleasingKeys: string[]\n  private _keyRemap: Record<string, string>\n\n  private _handlerStates: Record<string, HandlerState<KeyEvent<E>>[]>\n  private _keyComboStates: Record<string, KeyComboState<E>[]>\n  private _keyComboStatesArray: KeyComboState<E>[]\n  private _activeKeys: string[]\n  private _activeKeySet: Set<string>\n\n  private _watchedKeyComboStates: Record<string, KeyComboState<E>>\n\n  constructor(options: KeystrokesOptions<E> = {}) {\n    this._isActive = true\n    this._isUpdatingKeyComboState = false\n\n    this._onActiveBinder = options.onActive ?? defaultOnActiveBinder\n    this._onInactiveBinder = options.onInactive ?? defaultOnInactiveBinder\n    this._onKeyPressedBinder = options.onKeyPressed ?? (defaultOnKeyPressedBinder as any)\n    this._onKeyReleasedBinder = options.onKeyReleased ?? (defaultOnKeyReleasedBinder as any)\n    this._selfReleasingKeys = options.selfReleasingKeys ?? []\n    this._keyRemap = options.keyRemap ?? {}\n\n    this._handlerStates = {}\n    this._keyComboStates = {}\n    this._keyComboStatesArray = []\n    this._activeKeys = []\n    this._activeKeySet = new Set()\n\n    this._watchedKeyComboStates = {}\n\n    this.bindEnvironment()\n  }\n\n  get pressedKeys() {\n    return this._activeKeys.slice(0)\n  }\n\n  bindKey(key: string, handler: Handler<KeyEvent<E>>) {\n    key = key.toLowerCase()\n\n    const handlerState = new HandlerState(handler)\n    this._handlerStates[key] ??= []\n    this._handlerStates[key].push(handlerState)\n  }\n\n  unbindKey(key: string, handler?: Handler<KeyEvent<E>>) {\n    key = key.toLowerCase()\n\n    const handlerStates = this._handlerStates[key]\n    if (!handlerStates) {\n      return\n    }\n\n    if (handler) {\n      for (let i = 0; i < handlerStates.length; i += 1) {\n        if (handlerStates[i].isOwnHandler(handler)) {\n          handlerStates.splice(i, 1)\n          i -= 1\n        }\n      }\n    } else {\n      handlerStates.length = 0\n    }\n  }\n\n  bindKeyCombo(keyCombo: string, handler: Handler<KeyComboEvent<E>>) {\n    keyCombo = KeyComboState.normalizeKeyCombo(keyCombo)\n\n    const keyComboState = new KeyComboState<E>(keyCombo, handler)\n\n    this._keyComboStates[keyCombo] ??= []\n    this._keyComboStates[keyCombo].push(keyComboState)\n    this._keyComboStatesArray.push(keyComboState)\n  }\n\n  unbindKeyCombo(keyCombo: string, handler?: Handler<KeyComboEvent<E>>) {\n    keyCombo = KeyComboState.normalizeKeyCombo(keyCombo)\n\n    const keyComboStates = this._keyComboStates[keyCombo]\n    if (!keyComboStates) {\n      return\n    }\n\n    if (handler) {\n      for (let i = 0; i < keyComboStates.length; i += 1) {\n        if (keyComboStates[i].isOwnHandler(handler)) {\n          for (let j = 0; j < this._keyComboStatesArray.length; j += 1) {\n            if (this._keyComboStatesArray[j] === keyComboStates[i]) {\n              this._keyComboStatesArray.splice(j, 1)\n              j -= 1\n            }\n          }\n          keyComboStates.splice(i, 1)\n          i -= 1\n        }\n      }\n    } else {\n      keyComboStates.length = 0\n    }\n  }\n\n  checkKey(key: string) {\n    return this._activeKeySet.has(key.toLowerCase())\n  }\n\n  checkKeyCombo(keyCombo: string) {\n    keyCombo = KeyComboState.normalizeKeyCombo(keyCombo)\n    if (!this._watchedKeyComboStates[keyCombo]) {\n      this._watchedKeyComboStates[keyCombo] = new KeyComboState(keyCombo)\n    }\n    const keyComboState = this._watchedKeyComboStates[keyCombo]\n    keyComboState.updateState(this._activeKeys)\n    return keyComboState.isPressed\n  }\n\n  bindEnvironment() {\n    this.unbindEnvironment()\n\n    const unbindActive = this._onActiveBinder(() => {\n      this._isActive = true\n    })\n    const unbindInactive = this._onInactiveBinder(() => {\n      this._isActive = false\n    })\n    const unbindKeyPressed = this._onKeyPressedBinder(e => {\n      this._handleKeyPress(e)\n    })\n    const unbindKeyReleased = this._onKeyReleasedBinder(e => {\n      this._handleKeyRelease(e)\n    })\n\n    this._unbinder = () => {\n      unbindActive?.()\n      unbindInactive?.()\n      unbindKeyPressed?.()\n      unbindKeyReleased?.()\n    }\n  }\n\n  unbindEnvironment() {\n    this._unbinder?.()\n  }\n\n  private _handleKeyPress(event: KeyEvent<E>) {\n    ;(async () => {\n      if (!this._isActive) {\n        return\n      }\n\n      let key = event.key.toLowerCase()\n      const remappedKey = this._keyRemap[key]\n      if (remappedKey) {\n        key = remappedKey\n      }\n\n      const keyPressHandlerStates = this._handlerStates[key]\n      if (keyPressHandlerStates) {\n        for (const s of keyPressHandlerStates) {\n          s.executePressed(event)\n        }\n      }\n\n      if (!this._activeKeySet.has(key)) {\n        this._activeKeySet.add(key)\n        this._activeKeys.push(key)\n      }\n\n      await this._updateKeyComboStates()\n\n      for (const keyComboState of this._keyComboStatesArray) {\n        keyComboState.executePressed(event)\n      }\n    })().catch(err => {\n      console.error(err)\n    })\n  }\n\n  private _handleKeyRelease(event: KeyEvent<E>) {\n    ;(async () => {\n      const key = event.key.toLowerCase()\n\n      const keyPressHandlerStates = this._handlerStates[key]\n      if (keyPressHandlerStates) {\n        for (const s of keyPressHandlerStates) {\n          s.executeReleased(event)\n        }\n      }\n\n      if (this._activeKeySet.has(key)) {\n        this._activeKeySet.delete(key)\n        for (let i = 0; i < this._activeKeys.length; i += 1) {\n          if (this._activeKeys[i] === key) {\n            this._activeKeys.splice(i, 1)\n            i -= 1\n            break\n          }\n        }\n      }\n\n      this._tryReleaseSelfReleasingKeys()\n\n      await this._updateKeyComboStates()\n\n      for (const keyComboState of this._keyComboStatesArray) {\n        keyComboState.executeReleased(event)\n      }\n    })().catch(err => {\n      console.error(err)\n    })\n  }\n\n  private async _updateKeyComboStates() {\n    if (this._isUpdatingKeyComboState) {\n      return await nextTick()\n    }\n    this._isUpdatingKeyComboState = true\n\n    await nextTick()\n\n    for (const keyComboState of this._keyComboStatesArray) {\n      keyComboState.updateState(this._activeKeys)\n    }\n\n    this._isUpdatingKeyComboState = false\n  }\n\n  private _tryReleaseSelfReleasingKeys() {\n    for (const activeKey of this._activeKeys) {\n      let isSelfReleasingKey = false\n      for (const selfReleasingKey of this._selfReleasingKeys) {\n        if (activeKey === selfReleasingKey) {\n          isSelfReleasingKey = true\n          break\n        }\n      }\n      if (!isSelfReleasingKey) {\n        return\n      }\n    }\n\n    for (const activeKey of this._activeKeys) {\n      this._handleKeyRelease({ key: activeKey } as any)\n    }\n  }\n}\n","export type { KeyEvent, HandlerFn, HandlerObj, Handler } from './handler-state'\nexport type { KeyComboEvent } from './key-combo-state'\nexport type { OnActiveEventBinder, OnKeyEventBinder, KeystrokesOptions } from './keystrokes'\n\nimport { KeyComboState } from './key-combo-state'\nimport { Keystrokes, KeystrokesOptions } from './keystrokes'\n\nexport { Keystrokes } from './keystrokes'\n\nlet globalKeystrokesOptions: KeystrokesOptions\nlet globalKeystrokes: Keystrokes\nexport const getGlobalKeystrokesInstance = () => {\n  if (!globalKeystrokes) {\n    globalKeystrokes = new Keystrokes(globalKeystrokesOptions)\n  }\n  return globalKeystrokes\n}\n\nexport const setGlobalKeystrokesOptions = (options: KeystrokesOptions) => {\n  globalKeystrokesOptions = options\n}\n\nexport const bindKey: typeof globalKeystrokes.bindKey = (...args) =>\n  getGlobalKeystrokesInstance().bindKey(...args)\n\nexport const unbindKey: typeof globalKeystrokes.unbindKey = (...args) =>\n  getGlobalKeystrokesInstance().unbindKey(...args)\n\nexport const bindKeyCombo: typeof globalKeystrokes.bindKeyCombo = (...args) =>\n  getGlobalKeystrokesInstance().bindKeyCombo(...args)\n\nexport const unbindKeyCombo: typeof globalKeystrokes.unbindKeyCombo = (...args) =>\n  getGlobalKeystrokesInstance().unbindKeyCombo(...args)\n\nexport const checkKey: typeof globalKeystrokes.checkKey = (...args) =>\n  getGlobalKeystrokesInstance().checkKey(...args)\n\nexport const checkKeyCombo: typeof globalKeystrokes.checkKeyCombo = (...args) =>\n  getGlobalKeystrokesInstance().checkKeyCombo(...args)\n\nexport const normalizeKeyCombo = KeyComboState.normalizeKeyCombo\nexport const stringifyKeyCombo = KeyComboState.stringifyKeyCombo\nexport const parseKeyCombo = KeyComboState.parseKeyCombo\n","import { Keystrokes, parseKeyCombo, stringifyKeyCombo } from '@rwh/keystrokes'\n\n// const initialKeyCombo = 'a > s > d + f, g + h > j, k + l'\nconst initialKeyCombo = 'a > b, c + b'\n\nrun().catch(err => {\n  console.error(err)\n})\n\nasync function run() {\n  const keystrokes = new Keystrokes()\n\n  let keyComboStr = ''\n  const keyCombo = parseKeyCombo(initialKeyCombo)\n\n  const keyComboEl = document.querySelector<HTMLDivElement>('#key-combo')!\n  keyComboEl.innerHTML = stylizeKeyCombo(keyCombo, keystrokes.pressedKeys)\n  const originalBg = keyComboEl.style.background\n\n  const handleCombo = {\n    onPressed() {\n      keyComboEl.style.background = '#FFBF00'\n    },\n    onReleased() {\n      keyComboEl.style.background = originalBg\n    },\n  }\n\n  const bindKeyCombo = () => {\n    keystrokes.unbindKeyCombo(keyComboStr, handleCombo)\n    keyComboStr = stringifyKeyCombo(keyCombo)\n    keystrokes.bindKeyCombo(keyComboStr, handleCombo)\n  }\n\n  bindKeyCombo()\n\n  let standAloneShift = true\n  let pendingOperator = ''\n\n  document.addEventListener('keydown', () => {\n    keyComboEl.innerHTML = stylizeKeyCombo(keyCombo, keystrokes.pressedKeys)\n  })\n\n  document.addEventListener('keyup', () => {\n    keyComboEl.innerHTML = stylizeKeyCombo(keyCombo, keystrokes.pressedKeys)\n  })\n\n  keyComboEl.addEventListener('keydown', event => {\n    const key = event.key.toLowerCase()\n    if (key === 'shift') {\n      standAloneShift = true\n    }\n    console.log('down', standAloneShift)\n  })\n\n  keyComboEl.addEventListener('keyup', event => {\n    event.preventDefault()\n    event.stopImmediatePropagation()\n\n    const key = event.key.toLowerCase()\n\n    let lastSequence = keyCombo[keyCombo.length - 1]\n    let lastUnit = lastSequence?.[lastSequence.length - 1] ?? []\n\n    if (key !== 'shift') {\n      standAloneShift = false\n    }\n    if (key === 'backspace' && pendingOperator) {\n      pendingOperator = ''\n    } else if (key === 'backspace' && lastUnit.length !== 0) {\n      lastUnit.pop()\n      pendingOperator = '+'\n      if (lastUnit.length === 0) {\n        lastSequence.pop()\n        pendingOperator = '>'\n      }\n      if (lastSequence.length === 0) {\n        keyCombo.pop()\n        pendingOperator = ','\n      }\n      if (keyCombo.length === 0) {\n        pendingOperator = ''\n      }\n    } else if (key === 'enter') {\n      keyComboEl.blur()\n    } else if (key === '+' || key === '>' || key === ',') {\n      pendingOperator = key\n    } else if (pendingOperator && (key !== 'shift' || standAloneShift)) {\n      if (pendingOperator === '+') {\n        if (!lastSequence) {\n          lastSequence = []\n          keyCombo.push(lastSequence)\n        }\n        if (!lastUnit) {\n          lastUnit = []\n          lastSequence.push(lastUnit)\n        }\n        lastUnit.push(key)\n      } else if (pendingOperator === '>') {\n        lastUnit = [key]\n        if (!lastSequence) {\n          lastSequence = []\n          keyCombo.push(lastSequence)\n        }\n        lastSequence.push(lastUnit)\n      } else if (pendingOperator === ',') {\n        lastSequence = [[key]]\n        keyCombo.push(lastSequence)\n      }\n      pendingOperator = ''\n    } else if (key !== 'shift' || standAloneShift) {\n      if (!lastSequence) {\n        lastSequence = []\n        keyCombo.push(lastSequence)\n      }\n      if (!lastUnit) {\n        lastUnit = []\n        lastSequence.push(lastUnit)\n      }\n      lastUnit.pop()\n      lastUnit.push(key)\n    }\n\n    keyComboEl.innerHTML = stylizeKeyCombo(keyCombo, keystrokes.pressedKeys, pendingOperator)\n\n    bindKeyCombo()\n  })\n}\n\nfunction stylizeKeyCombo(keyCombo: string[][][], pressedKeys: string[], pendingOperator?: string) {\n  let stylizedKeyCombo = keyCombo\n    .map(\n      s =>\n        `<span class=\"sequence\">${s\n          .map(\n            u =>\n              `<span class=\"unit\">${u\n                .map(k => `<span class=\"key${pressedKeys.includes(k) ? ' pressed' : ''}\">${k}</span>`)\n                .join('<span class=\"join\"> + </span>')}</span>`,\n          )\n          .join('<span class=\"order\"> &gt; </span>')}</span>`,\n    )\n    .join('<span class=\"group\">, </span>')\n\n  switch (pendingOperator) {\n    case '+':\n      stylizedKeyCombo += '<span class=\"join\"> + </span>'\n      break\n    case '>':\n      stylizedKeyCombo += '<span class=\"order\"> &gt; </span>'\n      break\n    case ',':\n      stylizedKeyCombo += '<span class=\"group\">, </span>'\n      break\n  }\n\n  return stylizedKeyCombo\n}\n"],"names":["$539d70056b55f74d$export$2e2bcd8739ae039","obj","key","value","Object","defineProperty","enumerable","configurable","writable","$e28264399f6f57b9$var$$f323746ddedca5d6$export$7d68c18adf0621c5","isEmpty","this","_onPressed","_onPressedWithRepeat","_onReleased","isOwnHandler","handler","_identity","executePressed","event","_isPressed","executeReleased","constructor","onPressed","onPressedWithRepeat","onReleased","$e28264399f6f57b9$var$$cbc1b2a1218eedb5$export$ed36a648cd79390d","static","keyComboStr","_parseCache","s","toLowerCase","o","k","x","y","z","isEscaped","i","length","match","push","sequences","map","join","keyCombo","u","_normalizationCache","normalized","stringifyKeyCombo","parseKeyCombo","isPressed","_isPressedWithFinalKey","_handlerState","_wrapEvent","updateState","activeKeys","sequence","_parsedKeyCombo","_sequenceIndex","activeKeyIndex","unit","unitEndIndex","foundKey","activeKey","foundActiveKey","keyEvent","_normalizedKeyCombo","originalEvent","normalizeKeyCombo","$e28264399f6f57b9$var$$b48b34d93dc6249e$var$nextTickBinder","requestAnimationFrame","r","f","setTimeout","$e28264399f6f57b9$var$$b48b34d93dc6249e$export$bdd553fddd433dcb","Promise","$e28264399f6f57b9$var$$b48b34d93dc6249e$var$defaultOnActiveBinder","handlerWrapper","addEventListener","removeEventListener","$e28264399f6f57b9$var$$b48b34d93dc6249e$var$defaultOnInactiveBinder","$e28264399f6f57b9$var$$b48b34d93dc6249e$var$defaultOnKeyPressedBinder","e","document","$e28264399f6f57b9$var$$b48b34d93dc6249e$var$defaultOnKeyReleasedBinder","$e28264399f6f57b9$export$2f47270a5e20576c","pressedKeys","_activeKeys","slice","bindKey","handlerState","_handlerStates","unbindKey","handlerStates","splice","bindKeyCombo","keyComboState","_keyComboStates","_keyComboStatesArray","unbindKeyCombo","keyComboStates","j","checkKey","_activeKeySet","has","checkKeyCombo","_watchedKeyComboStates","bindEnvironment","unbindEnvironment","unbindActive","_onActiveBinder","_isActive","unbindInactive","_onInactiveBinder","unbindKeyPressed","_onKeyPressedBinder","_handleKeyPress","unbindKeyReleased","_onKeyReleasedBinder","_handleKeyRelease","_unbinder","remappedKey","_keyRemap","keyPressHandlerStates","add","_updateKeyComboStates","catch","err","console","error","delete","_tryReleaseSelfReleasingKeys","async","_isUpdatingKeyComboState","isSelfReleasingKey","selfReleasingKey","_selfReleasingKeys","options","onActive","onInactive","onKeyPressed","onKeyReleased","selfReleasingKeys","keyRemap","Set","$e28264399f6f57b9$export$531394fdfe259c9e","$e28264399f6f57b9$export$c9a05b4f8b6ef437","$f090d66be08df881$var$stylizeKeyCombo","pendingOperator","stylizedKeyCombo","includes","keystrokes","keyComboEl","querySelector","innerHTML","originalBg","style","background","handleCombo","standAloneShift","log","preventDefault","stopImmediatePropagation","lastSequence","lastUnit","pop","blur","$f090d66be08df881$var$run"],"version":3,"file":"index.8ee00b2f.js.map"}